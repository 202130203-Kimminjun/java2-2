# 김민준 202130203

## 4월5일
**2차원 배열**  
int (배열이름)[] = new int[2][5];  
    └ 2개의 파일 안에 5개의 파일이 또 있다고 생각하면 편하다.  
char (배열이름)[][] = {{'a','b','c',},{'d','e','f'}}; 【3x2 배열 생성.】  

**자바의 예외처리**  
*예외(Exception)* = 자바에서 실행 중 발생하는 에러.  
```
try {  
    예외가 발생할 가능성이 있는 실행문(try 블록)  
}  
catch (처리할 예외 타입 선언){  
    예외 처리문(catch 블록)  
}  
finally{  
    예외 발생 여부와 상관없이 무조건 실행되는 문장(finally 블록)  
}  
```
**이 세상은 일말의 거리낌도 없이, 이 모든 것이 『객체』다.**  
class : 객체 모양을 선언한 틀.  
자바 상속 > 상위의 클래스를 하위 클래스가 물려받음.  
객체지향 언어의 목적은 당연 생산성이다.  
    └ 실세계의 일을 보다 쉽게 프로그래밍하기 위함.  

클래스 생성과 생성자를 이용한 코드 제작을 연습했다. 예제는 src 안의 ***Test.java***이다. (전에 했던 코드들은 주석처리 해놓음.)

**생성자**  
▶ 생성자의 목적은 객체 생성 시 초기화를 하기 위함이다.  
▶ 생성자는 중복 가능. 여러개 생성 가능.  
▶ 생성자는 객체 생성시 한번만 호출.  
▶ 생성자는 리턴 타입 지정 X.  
생성자가 생성되지 않았을 경우, 컴파일러가 *자동 삽입* 해주는 듯 하다.

**this 레퍼런스**  
중복을 없애려고 사용하는 듯 하다. 생성자 내에서 가장 첫 줄에 있어야 함. *조금 이해하기 힘든 개념이다...*  

**메소드**  
ㆍ 자바의 모든 메소드는 반드시 클래스 안에 있어야 함(캡슐화 원칙)  
▶ 접근 지정자 : 다른 클래스에서 메소드 접근할 수 있는지 여부.  
▶ 리턴 타입 : 메소드가 리턴하는 값의 데이터 타입  
【오버로딩】 : 한 클래스 내에서 2개 이상의 이름이 같은 메소드 작성.  
    └ 메소드 이름이 동일해야 함.  
    └ 매개 변수의 개수가 다르가나, 타입이 달라야함.  

**가비지**  
가리키는 레퍼런스가 없는 객체.  
```
Person a, b;
a = new Person("이몽룡");
b = new Person("성춘향");

b = a;
```
이러면 b(성춘향이 들어가 있음)를 a(이몽룡이 들어가 있음)로 덮어서 넣어버렸고, 원래 b였던 "성춘향"은 버려지게되었다. 이건 *가비지*다.  
※**가비지 컬렉터**라는 가상의 무언가가 가비지를 자동 회수한다.
    └ System.gc();   =   가비지 컬렉션 작동.

## 3월29일
**여러가지**  
String = 문자열  
상수선언하려면 final (데이터타입) (상수이름) = (값).  
var = 아주 간편하게 타입 생략하고 변수 선언가능. 값을 비우면 오류!  
System.out.println = 키보드로 값 입력.  
scanner = 입력한 값을 읽어서 타입별로 리턴. 위에랑 같이 사용함.  

**연산자**  
ㆍ +, -, *, / (사칙연산) , % = 나누고 나머지 값 계산.  
ㆍ a++ , a-- (a를 1 증가,감소하고 계산되기 전의 값 반환.)  
ㆍ ++a , --a (a를 1 증가,감소한 값 반환.)  
ㆍ < ,> ,== , != (부등호와 등호. 같지 않은 경우 !=)  
ㆍ !a (a가 true면 false, false면 true)  
ㆍ a^b (a=b이면 false)  
ㆍ a||b(a와b 모두 false면 false) , a&&b (a,b 모두 true면 true)  
ㆍ (하나)?(둘):(셋) = 하나가 참이면 둘. 아니면 셋. (if-else)로 치환가능.  

**if**문과 **else**문을 배웠다. 그와 비슷한 **case와 switch**의 사용법도 배웠다. 실습이 더 필요할 듯 하다. ← 예시로 만들어본 if-else문 예제는 src 안의 ***Test.java***이다.

**for(초기문; 조건식; 반복 후 작업) { ~작업문~ }**  
반복문.

**배열(array)** : 인덱스와 인덱스에 대응하는 데이터들로 이루어진 자료구조. 0부터 시작.  
*int (배열이름)[];* 또는 *int[] (배열이름);* ← 크기 지정 안됨 [] 안에 값 못 넣는다.  
*intArray = new int[5];* 또는 ***int (배열이름)[] = new int[5];*** 보통 이런 식으로 선언 하는듯.  
int intArray = new int[5]; (인덱스 0~4까지 5개 놓았음.)
intArray[2] = 5; (2번에 5 넣음. []안에 번호, = 뒤에 값을 넣어줌.)  
int n = intArray[3]; (2번의 값을 n에 넣음. 위에 보면 2번에는 5가 들어있음ㅋ.)  
※intArray[] 안에 음수 못 넣음.  
(배열이름).length 해서 배열값을 편하게 불러 받을 수 있다.

## 3월22일
새 프로젝트 생성 후 안의 디렉토리만 복사, 원래 쓰던 파일에 붙여넣기 했다. 이후 자바 파일을 Run 돌려보니 작동하는 걸 확인했다. 이후 프로그램 작성언어와 WORA, 컴파일에 대하여, 자바SE의 구성을 학습하였다. 아직은 아리송하다.

자바의 특성. 소스(.java)와 클래스(.class), 하나의 소스 파일에 여러 클래스를 작성 가능하다. 소스파일 이름과 클래스 이름은 같아야함. 어떤 클래스든 메인 메소드에서 시작. Ctrl + / 를 누르면 주석으로 전환된다.

8가지의 데이터 기본 타입을 다시금 알게 되었다.

Java 파일을 생성하고 **Window Powershall** 안에서 실행도 시켜보았다. cd ~로 자바 파일이 있는 프로젝트 파일에 들어가 자바 파일을 실행시켜 보았더니 잘 나왔다. (javac Foo.java → java Foo) 보아하니 탐색기 왼쪽 맨 위의 파일 탭에서 'Windows Powershall로 열기'를 누르면 간편히 실행된다. 처음 아는 사실이었다.

## 3월15일
**Github**를 통하여 클론을 이용, 내 컴퓨터에 여러 파일을 불러왔다.
여기서 불러온 것을 수정을 하여 변경된 사항을 Commit 하여 Github 자체에 업데이트를 하였다.

 **.gitignore**에서 올리고 싶지 않은 파일이나 디렉토리를 적어 올리지 않는 방법 또한 익혔다.
 (*.gif) < 이런 식으로 해당 확장자 전체를 올리지 않을 수도 있고, job/ 과 같이 디렉토리를 올리지 않을 수 있다.

 **Commit** 할 때에는 제목을 적어 commit 해야한다. Commit 하니 Github에서 변경된 사항이 업데이트 된 것을 확인할 수 있었다.

 **Java**를 VSCode에서 만들어보았다. 이클립스보다 간편하게 Java파일을 다루어볼 수 있었다. 자바 파일을 만들 때는 파일의 첫 글자를 대문자로 한다.(파스칼표기법이라나 뭐라나)

 ## 3월8일
 개행하려면 스페이스 2개 입력  
가나다  
라마바  

*이탤릭체* - **볼드** - ***이탤릭 + 볼드***  

리스트 <list>
1. 김민준
2. 김민준
8. 김민준
4. 김민준
5. 김민준

* 안양시
    * 동안구
        * 호계동
- 안양시
    - 만안구
        - 박달동